(ns sudoku.core)

(defn random-generator [num]
  (inc (rand-int num)))

(defn un-used-in-box [mat row-start col-start num]
  (let [srn (int (Math/sqrt (count mat)))]
    (every? #(not= num %) (for [i (range srn) j (range srn)] (get-in mat [(+ row-start i) (+ col-start j)])))))

(defn fill-box [mat row col]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (let [nums (shuffle (range 1 (inc n)))
          i (rand-int srn)
          j (rand-int srn)
          new-row (+ row i)
          new-col (+ col j)]
      (loop [nums nums]
        (if (empty? nums)
          mat
          (let [num (first nums)]
            (if (un-used-in-box mat row col num)
              (recur (rest nums))
              (recur nums))))))))

(defn check-if-safe [mat i j num]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (and (every? #(not= num %) (get mat i))
         (every? #(not= num %) (map #(get % j) mat))
         (un-used-in-box mat (- i (mod i srn)) (- j (mod j srn)) num))))

(defn fill-remaining-helper [mat i j]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (if (>= j n)
      (fill-remaining-helper mat (inc i) 0)
      (if (>= i n)
        true
        (if (< i srn)
          (if (< j srn)
            (fill-remaining-helper mat i srn)
            (fill-remaining-helper mat i (inc j)))
          (if (< i (- n srn))
            (if (= j (* srn (quot i srn)))
              (fill-remaining-helper mat i (inc j))
              (fill-remaining-helper mat i j))
            (if (= j (- n srn))
              (fill-remaining-helper mat (inc i) 0)
              (let [nums (range 1 (inc n))]
                (some #(let [num %]
                         (if (check-if-safe mat i j num)
                           (do
                             (assoc-in mat [i j] num)
                             (if (fill-remaining-helper mat i (inc j))
                               true
                               (do
                                 (assoc-in mat [i j] 0)
                                 false)))
                           false) nums))))))))))

(defn fill-remaining [mat i j]
  (fill-remaining-helper mat i j))

(defn remove-k-digits [mat k]
  (let [n (count mat)]
    (loop [count k]
      (if (zero? count)
        mat
        (let [cell-id (dec (random-generator (* n n)))
              i (quot cell-id n)
              j (mod cell-id n)]
          (if (not= 0 (get-in mat [i j]))
            (recur (dec count))
            (recur count)))))))

(defn print-sudoku [mat]
  (doseq [row mat]
    (println (clojure.string/join " " row)))
  (println))

(defn fill-values [n k]
  (let [srn (int (Math/sqrt n))
        mat (vec (repeat n (vec (repeat n 0))))]
    (doseq [i (for [x (range 0 n) :when (zero? (mod x srn))] x)
            j (for [x (range 0 n) :when (zero? (mod x srn))] x)]
      (fill-box mat i j))
    (fill-remaining mat 0 srn)
    (remove-k-digits mat k)
    mat))

(defn -main []
  (let [n 9
        k 20
        sudoku (fill-values n k)]
    (print-sudoku sudoku)))

(-main)
