(ns sudoku.core)

(defn random-generator [num]
  (inc (rand-int num)))

(defn un-used-in-box [mat row-start col-start num]
  (let [srn (int (Math/sqrt (count mat)))]
    (every? #(not= num %) (for [i (range srn)
                                j (range srn)]
                            (get-in mat [(+ row-start i) (+ col-start j)])))))

(defn fill-box [mat row col]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (doseq [i (range srn)
            j (range srn)]
      (loop [num (random-generator n)]
        (if-not (un-used-in-box mat row col num)
          (recur (random-generator n))
          (assoc-in mat [(+ row i) (+ col j)] num))))))

(defn check-if-safe [mat i j num]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (and (every? #(not= num %) (get mat i))
         (every? #(not= num %) (map #(get % j) mat))
         (un-used-in-box mat (- i (mod i srn)) (- j (mod j srn)) num))))

(defn fill-remaining [mat i j]
  (let [n (count mat)
        srn (int (Math/sqrt n))]
    (if (>= j n)
      (recur (inc i) 0)
      (if (>= i n)
        true
        (if (< i srn)
          (if (< j srn)
            (recur i srn)
            (recur i (inc j)))
          (if (< i (- n srn))
            (if (= j (* srn (quot i srn)))
              (recur i (inc j))
              (recur i j))
            (if (= j (- n srn))
              (recur (inc i) 0)
              (loop [num 1]
                (if (<= num n)
                  (if (check-if-safe mat i j num)
                    (do
                      (assoc-in mat [i j] num)
                      (if (recur i (inc j))
                        true
                        (assoc-in mat [i j] 0)))
                    (recur (inc num)))
                  false))))))))

(defn remove-k-digits [mat k]
  (let [n (count mat)]
    (loop [count k]
      (if (zero? count)
        mat
        (let [cell-id (dec (random-generator (* n n)))
              i (quot cell-id n)
              j (mod cell-id n)]
          (if (not= (get-in mat [i j]) 0)
            (recur (dec count))
            (recur count))))))

(defn print-sudoku [mat]
  (doseq [row mat]
    (println (clojure.string/join " " row)))
  (println))

(defn fill-values [n k]
  (let [srn (int (Math/sqrt n))
        mat (vec (repeat n (vec (repeat n 0))))]
    (doseq [i (range 0 n srn)
            j (range 0 n srn)]
      (fill-box mat i j))
    (fill-remaining mat 0 srn)
    (print-sudoku mat)
    (remove-k-digits mat k)))

(defn validate-grid-size [n]
  (let [sqrt-n (Math/sqrt n)]
    (and (integer? sqrt-n)
         (zero? (mod n sqrt-n)))))

(defn -main []
  (let [n 9
        k 20]
    (if (validate-grid-size n)
      (fill-values n k)
      (println "Invalid grid size. Please enter a perfect square number."))))
